import {
  __toModule
} from "./chunk.5JD2HCIV.js";
import "./chunk.FNFVRXQK.js";
import {
  require_react
} from "./chunk.BD4KNU7W.js";
import "./chunk.MXG56MB2.js";
import "./chunk.5OSL2VXB.js";
import {
  __name
} from "./chunk.C4F35LU4.js";

// ../.yarn/$$virtual/react-virtual-virtual-cacec6f605/0/cache/react-virtual-npm-2.6.1-b4b8e46a1e-40c2810219.zip/node_modules/react-virtual/dist/react-virtual.mjs
var import_react = __toModule(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
var props = ["bottom", "height", "left", "right", "top", "width"];
var rectChanged = /* @__PURE__ */ __name(function rectChanged2(a, b) {
  if (a === void 0) {
    a = {};
  }
  if (b === void 0) {
    b = {};
  }
  return props.some(function(prop) {
    return a[prop] !== b[prop];
  });
}, "rectChanged");
var observedNodes = new Map();
var rafId;
var run = /* @__PURE__ */ __name(function run2() {
  var changedStates = [];
  observedNodes.forEach(function(state, node) {
    var newRect = node.getBoundingClientRect();
    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function(state) {
    state.callbacks.forEach(function(cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run2);
}, "run");
function observeRect(node, cb) {
  return {
    observe: /* @__PURE__ */ __name(function observe() {
      var wasEmpty = observedNodes.size === 0;
      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: void 0,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }
      if (wasEmpty)
        run();
    }, "observe"),
    unobserve: /* @__PURE__ */ __name(function unobserve() {
      var state = observedNodes.get(node);
      if (state) {
        var index = state.callbacks.indexOf(cb);
        if (index >= 0)
          state.callbacks.splice(index, 1);
        if (!state.callbacks.length)
          observedNodes["delete"](node);
        if (!observedNodes.size)
          cancelAnimationFrame(rafId);
      }
    }, "unobserve")
  };
}
__name(observeRect, "observeRect");
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function useRect(nodeRef) {
  var _React$useState = import_react.default.useState(nodeRef.current), element = _React$useState[0], setElement = _React$useState[1];
  var _React$useReducer = import_react.default.useReducer(rectReducer, null), rect = _React$useReducer[0], dispatch = _React$useReducer[1];
  var initialRectSet = import_react.default.useRef(false);
  useIsomorphicLayoutEffect(function() {
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (element && !initialRectSet.current) {
      initialRectSet.current = true;
      var _rect = element.getBoundingClientRect();
      dispatch({
        rect: _rect
      });
    }
  }, [element]);
  import_react.default.useEffect(function() {
    if (!element) {
      return;
    }
    var observer = observeRect(element, function(rect2) {
      dispatch({
        rect: rect2
      });
    });
    observer.observe();
    return function() {
      observer.unobserve();
    };
  }, [element]);
  return rect;
}
__name(useRect, "useRect");
function rectReducer(state, action) {
  var rect = action.rect;
  if (!state || state.height !== rect.height || state.width !== rect.width) {
    return rect;
  }
  return state;
}
__name(rectReducer, "rectReducer");
var defaultEstimateSize = /* @__PURE__ */ __name(function defaultEstimateSize2() {
  return 50;
}, "defaultEstimateSize");
var defaultKeyExtractor = /* @__PURE__ */ __name(function defaultKeyExtractor2(index) {
  return index;
}, "defaultKeyExtractor");
function useVirtual(_ref) {
  var _ref3, _measurements;
  var _ref$size = _ref.size, size = _ref$size === void 0 ? 0 : _ref$size, _ref$estimateSize = _ref.estimateSize, estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize, _ref$overscan = _ref.overscan, overscan = _ref$overscan === void 0 ? 0 : _ref$overscan, _ref$paddingStart = _ref.paddingStart, paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart, _ref$paddingEnd = _ref.paddingEnd, paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd, parentRef = _ref.parentRef, horizontal = _ref.horizontal, scrollToFn = _ref.scrollToFn, useObserver = _ref.useObserver, onScrollElement = _ref.onScrollElement, scrollOffsetFn = _ref.scrollOffsetFn, _ref$keyExtractor = _ref.keyExtractor, keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor;
  var sizeKey = horizontal ? "width" : "height";
  var scrollKey = horizontal ? "scrollLeft" : "scrollTop";
  var latestRef = import_react.default.useRef({});
  var useMeasureParent = useObserver || useRect;
  var _ref2 = useMeasureParent(parentRef) || (_ref3 = {}, _ref3[sizeKey] = 0, _ref3), outerSize = _ref2[sizeKey];
  var defaultScrollToFn = import_react.default.useCallback(function(offset) {
    if (parentRef.current) {
      parentRef.current[scrollKey] = offset;
    }
  }, [parentRef, scrollKey]);
  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;
  scrollToFn = import_react.default.useCallback(function(offset) {
    resolvedScrollToFn(offset, defaultScrollToFn);
  }, [defaultScrollToFn, resolvedScrollToFn]);
  var _React$useState = import_react.default.useState({}), measuredCache = _React$useState[0], setMeasuredCache = _React$useState[1];
  var measure = import_react.default.useCallback(function() {
    return setMeasuredCache({});
  }, []);
  var measurements = import_react.default.useMemo(function() {
    var measurements2 = [];
    for (var i = 0; i < size; i++) {
      var measuredSize = measuredCache[keyExtractor(i)];
      var start = measurements2[i - 1] ? measurements2[i - 1].end : paddingStart;
      var _size = typeof measuredSize === "number" ? measuredSize : estimateSize(i);
      var end = start + _size;
      measurements2[i] = {
        index: i,
        start,
        size: _size,
        end
      };
    }
    return measurements2;
  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);
  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || 0) + paddingEnd;
  Object.assign(latestRef.current, {
    overscan,
    measurements,
    outerSize,
    totalSize
  });
  var _React$useState2 = import_react.default.useState({
    start: 0,
    end: 0
  }), range = _React$useState2[0], setRange = _React$useState2[1];
  var element = onScrollElement ? onScrollElement.current : parentRef.current;
  useIsomorphicLayoutEffect(function() {
    if (!element) {
      return;
    }
    var onScroll = /* @__PURE__ */ __name(function onScroll2() {
      var scrollOffset = scrollOffsetFn ? scrollOffsetFn() : element[scrollKey];
      latestRef.current.scrollOffset = scrollOffset;
      setRange(function(prevRange) {
        return calculateRange(latestRef.current, prevRange);
      });
    }, "onScroll");
    onScroll();
    element.addEventListener("scroll", onScroll, {
      capture: false,
      passive: true
    });
    return function() {
      element.removeEventListener("scroll", onScroll);
    };
  }, [
    element,
    scrollKey,
    size,
    outerSize
  ]);
  var virtualItems = import_react.default.useMemo(function() {
    var virtualItems2 = [];
    var end = Math.min(range.end, measurements.length - 1);
    var _loop = /* @__PURE__ */ __name(function _loop2(i2) {
      var measurement = measurements[i2];
      var item = _extends(_extends({}, measurement), {}, {
        measureRef: /* @__PURE__ */ __name(function measureRef(el) {
          var scrollOffset = latestRef.current.scrollOffset;
          if (el) {
            var _el$getBoundingClient = el.getBoundingClientRect(), measuredSize = _el$getBoundingClient[sizeKey];
            if (measuredSize !== item.size) {
              if (item.start < scrollOffset) {
                defaultScrollToFn(scrollOffset + (measuredSize - item.size));
              }
              setMeasuredCache(function(old) {
                var _extends2;
                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[keyExtractor(i2)] = measuredSize, _extends2));
              });
            }
          }
        }, "measureRef")
      });
      virtualItems2.push(item);
    }, "_loop");
    for (var i = range.start; i <= end; i++) {
      _loop(i);
    }
    return virtualItems2;
  }, [range.start, range.end, measurements, sizeKey, defaultScrollToFn, keyExtractor]);
  var mountedRef = import_react.default.useRef();
  useIsomorphicLayoutEffect(function() {
    if (mountedRef.current) {
      if (estimateSize)
        setMeasuredCache({});
    }
    mountedRef.current = true;
  }, [estimateSize]);
  var scrollToOffset = import_react.default.useCallback(function(toOffset, _temp) {
    var _ref4 = _temp === void 0 ? {} : _temp, _ref4$align = _ref4.align, align = _ref4$align === void 0 ? "start" : _ref4$align;
    var _latestRef$current = latestRef.current, scrollOffset = _latestRef$current.scrollOffset, outerSize2 = _latestRef$current.outerSize;
    if (align === "auto") {
      if (toOffset <= scrollOffset) {
        align = "start";
      } else if (toOffset >= scrollOffset + outerSize2) {
        align = "end";
      } else {
        align = "start";
      }
    }
    if (align === "start") {
      scrollToFn(toOffset);
    } else if (align === "end") {
      scrollToFn(toOffset - outerSize2);
    } else if (align === "center") {
      scrollToFn(toOffset - outerSize2 / 2);
    }
  }, [scrollToFn]);
  var tryScrollToIndex = import_react.default.useCallback(function(index, _temp2) {
    var _ref5 = _temp2 === void 0 ? {} : _temp2, _ref5$align = _ref5.align, align = _ref5$align === void 0 ? "auto" : _ref5$align, rest = _objectWithoutPropertiesLoose(_ref5, ["align"]);
    var _latestRef$current2 = latestRef.current, measurements2 = _latestRef$current2.measurements, scrollOffset = _latestRef$current2.scrollOffset, outerSize2 = _latestRef$current2.outerSize;
    var measurement = measurements2[Math.max(0, Math.min(index, size - 1))];
    if (!measurement) {
      return;
    }
    if (align === "auto") {
      if (measurement.end >= scrollOffset + outerSize2) {
        align = "end";
      } else if (measurement.start <= scrollOffset) {
        align = "start";
      } else {
        return;
      }
    }
    var toOffset = align === "center" ? measurement.start + measurement.size / 2 : align === "end" ? measurement.end : measurement.start;
    scrollToOffset(toOffset, _extends({
      align
    }, rest));
  }, [scrollToOffset, size]);
  var scrollToIndex = import_react.default.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    tryScrollToIndex.apply(void 0, args);
    requestAnimationFrame(function() {
      tryScrollToIndex.apply(void 0, args);
    });
  }, [tryScrollToIndex]);
  return {
    virtualItems,
    totalSize,
    scrollToOffset,
    scrollToIndex,
    measure
  };
}
__name(useVirtual, "useVirtual");
function calculateRange(_ref6, prevRange) {
  var overscan = _ref6.overscan, measurements = _ref6.measurements, outerSize = _ref6.outerSize, scrollOffset = _ref6.scrollOffset;
  var total = measurements.length;
  var start = total - 1;
  while (start > 0 && measurements[start].end >= scrollOffset) {
    start -= 1;
  }
  var end = 0;
  while (end < total - 1 && measurements[end].start <= scrollOffset + outerSize) {
    end += 1;
  }
  start = Math.max(start - overscan, 0);
  end = Math.min(end + overscan, total - 1);
  if (!prevRange || prevRange.start !== start || prevRange.end !== end) {
    return {
      start,
      end
    };
  }
  return prevRange;
}
__name(calculateRange, "calculateRange");
export {
  useVirtual
};
//# sourceMappingURL=react-virtual.js.map
