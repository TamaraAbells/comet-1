import {
  invariant
} from "./chunk.USDFEUXJ.js";
import {
  __name
} from "./chunk.C4F35LU4.js";

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/interfaces.js
var ListenerType;
(function(ListenerType2) {
  ListenerType2["mouse"] = "mouse";
  ListenerType2["touch"] = "touch";
  ListenerType2["keyboard"] = "keyboard";
})(ListenerType || (ListenerType = {}));

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/utils/predicates.js
var MouseButtons = {
  Left: 1,
  Right: 2,
  Center: 4
};
var MouseButton = {
  Left: 0,
  Center: 1,
  Right: 2
};
function eventShouldStartDrag(e) {
  return e.button === void 0 || e.button === MouseButton.Left;
}
__name(eventShouldStartDrag, "eventShouldStartDrag");
function eventShouldEndDrag(e) {
  return e.buttons === void 0 || (e.buttons & MouseButtons.Left) === 0;
}
__name(eventShouldEndDrag, "eventShouldEndDrag");
function isTouchEvent(e) {
  return !!e.targetTouches;
}
__name(isTouchEvent, "isTouchEvent");

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/utils/offsets.js
var ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el) {
    return void 0;
  }
  var _el$getBoundingClient = el.getBoundingClientRect(), top = _el$getBoundingClient.top, left = _el$getBoundingClient.left;
  return {
    x: left,
    y: top
  };
}
__name(getNodeClientOffset, "getNodeClientOffset");
function getEventClientTouchOffset(e, lastTargetTouchFallback) {
  if (e.targetTouches.length === 1) {
    return getEventClientOffset(e.targetTouches[0]);
  } else if (lastTargetTouchFallback && e.touches.length === 1) {
    if (e.touches[0].target === lastTargetTouchFallback.target) {
      return getEventClientOffset(e.touches[0]);
    }
  }
}
__name(getEventClientTouchOffset, "getEventClientTouchOffset");
function getEventClientOffset(e, lastTargetTouchFallback) {
  if (isTouchEvent(e)) {
    return getEventClientTouchOffset(e, lastTargetTouchFallback);
  } else {
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
}
__name(getEventClientOffset, "getEventClientOffset");

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/utils/math.js
function distance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));
}
__name(distance, "distance");
function inAngleRanges(x1, y1, x2, y2, angleRanges) {
  if (!angleRanges) {
    return false;
  }
  var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI + 180;
  for (var i = 0; i < angleRanges.length; ++i) {
    if ((angleRanges[i].start == null || angle >= angleRanges[i].start) && (angleRanges[i].end == null || angle <= angleRanges[i].end)) {
      return true;
    }
  }
  return false;
}
__name(inAngleRanges, "inAngleRanges");

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/utils/supportsPassive.js
var supportsPassive = function() {
  var supported = false;
  try {
    addEventListener("test", function() {
    }, Object.defineProperty({}, "passive", {
      get: /* @__PURE__ */ __name(function get() {
        supported = true;
        return true;
      }, "get")
    }));
  } catch (e) {
  }
  return supported;
}();

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/OptionsReader.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
__name(_createClass, "_createClass");
var OptionsReader = function() {
  function OptionsReader2(incoming, context) {
    var _this = this;
    _classCallCheck(this, OptionsReader2);
    this.enableTouchEvents = true;
    this.enableMouseEvents = false;
    this.enableKeyboardEvents = false;
    this.ignoreContextMenu = false;
    this.enableHoverOutsideTarget = false;
    this.touchSlop = 0;
    this.scrollAngleRanges = void 0;
    this.context = context;
    this.delayTouchStart = incoming.delayTouchStart || incoming.delay || 0;
    this.delayMouseStart = incoming.delayMouseStart || incoming.delay || 0;
    Object.keys(incoming).forEach(function(key) {
      if (incoming[key] != null) {
        ;
        _this[key] = incoming[key];
      }
    });
  }
  __name(OptionsReader2, "OptionsReader");
  _createClass(OptionsReader2, [{
    key: "window",
    get: /* @__PURE__ */ __name(function get() {
      if (this.context && this.context.window) {
        return this.context.window;
      } else if (typeof window !== "undefined") {
        return window;
      }
      return void 0;
    }, "get")
  }, {
    key: "document",
    get: /* @__PURE__ */ __name(function get() {
      var _this$context;
      if ((_this$context = this.context) !== null && _this$context !== void 0 && _this$context.document) {
        return this.context.document;
      }
      if (this.window) {
        return this.window.document;
      }
      return void 0;
    }, "get")
  }]);
  return OptionsReader2;
}();

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/TouchBackendImpl.js
var _eventNames;
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck2, "_classCallCheck");
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
__name(_defineProperties2, "_defineProperties");
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
__name(_createClass2, "_createClass");
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
var eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {
  start: "mousedown",
  move: "mousemove",
  end: "mouseup",
  contextmenu: "contextmenu"
}), _defineProperty(_eventNames, ListenerType.touch, {
  start: "touchstart",
  move: "touchmove",
  end: "touchend"
}), _defineProperty(_eventNames, ListenerType.keyboard, {
  keydown: "keydown"
}), _eventNames);
var TouchBackendImpl = function() {
  function TouchBackendImpl2(manager, context, options) {
    var _this = this;
    _classCallCheck2(this, TouchBackendImpl2);
    this.getSourceClientOffset = function(sourceId) {
      var element = _this.sourceNodes.get(sourceId);
      return element && getNodeClientOffset(element);
    };
    this.handleTopMoveStartCapture = function(e) {
      if (!eventShouldStartDrag(e)) {
        return;
      }
      _this.moveStartSourceIds = [];
    };
    this.handleMoveStart = function(sourceId) {
      if (Array.isArray(_this.moveStartSourceIds)) {
        _this.moveStartSourceIds.unshift(sourceId);
      }
    };
    this.handleTopMoveStart = function(e) {
      if (!eventShouldStartDrag(e)) {
        return;
      }
      var clientOffset = getEventClientOffset(e);
      if (clientOffset) {
        if (isTouchEvent(e)) {
          _this.lastTargetTouchFallback = e.targetTouches[0];
        }
        _this._mouseClientOffset = clientOffset;
      }
      _this.waitingForDelay = false;
    };
    this.handleTopMoveStartDelay = function(e) {
      if (!eventShouldStartDrag(e)) {
        return;
      }
      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;
      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);
      _this.waitingForDelay = true;
    };
    this.handleTopMoveCapture = function() {
      _this.dragOverTargetIds = [];
    };
    this.handleMove = function(_evt, targetId) {
      if (_this.dragOverTargetIds) {
        _this.dragOverTargetIds.unshift(targetId);
      }
    };
    this.handleTopMove = function(e) {
      if (_this.timeout) {
        clearTimeout(_this.timeout);
      }
      if (!_this.document || _this.waitingForDelay) {
        return;
      }
      var moveStartSourceIds = _this.moveStartSourceIds, dragOverTargetIds = _this.dragOverTargetIds;
      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;
      var clientOffset = getEventClientOffset(e, _this.lastTargetTouchFallback);
      if (!clientOffset) {
        return;
      }
      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {
        _this._isScrolling = true;
        return;
      }
      if (!_this.monitor.isDragging() && _this._mouseClientOffset.hasOwnProperty("x") && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {
        _this.moveStartSourceIds = void 0;
        _this.actions.beginDrag(moveStartSourceIds, {
          clientOffset: _this._mouseClientOffset,
          getSourceClientOffset: _this.getSourceClientOffset,
          publishSource: false
        });
      }
      if (!_this.monitor.isDragging()) {
        return;
      }
      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());
      _this.installSourceNodeRemovalObserver(sourceNode);
      _this.actions.publishDragSource();
      if (e.cancelable)
        e.preventDefault();
      var dragOverTargetNodes = (dragOverTargetIds || []).map(function(key) {
        return _this.targetNodes.get(key);
      }).filter(function(e2) {
        return !!e2;
      });
      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y);
      var elementsAtPointExtended = [];
      for (var nodeId in elementsAtPoint) {
        if (!elementsAtPoint.hasOwnProperty(nodeId)) {
          continue;
        }
        var currentNode = elementsAtPoint[nodeId];
        elementsAtPointExtended.push(currentNode);
        while (currentNode) {
          currentNode = currentNode.parentElement;
          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {
            elementsAtPointExtended.push(currentNode);
          }
        }
      }
      var orderedDragOverTargetIds = elementsAtPointExtended.filter(function(node) {
        return dragOverTargetNodes.indexOf(node) > -1;
      }).map(function(node) {
        return _this._getDropTargetId(node);
      }).filter(function(node) {
        return !!node;
      }).filter(function(id, index, ids) {
        return ids.indexOf(id) === index;
      });
      if (enableHoverOutsideTarget) {
        for (var targetId in _this.targetNodes) {
          var targetNode = _this.targetNodes.get(targetId);
          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {
            orderedDragOverTargetIds.unshift(targetId);
            break;
          }
        }
      }
      orderedDragOverTargetIds.reverse();
      _this.actions.hover(orderedDragOverTargetIds, {
        clientOffset
      });
    };
    this._getDropTargetId = function(node) {
      var keys = _this.targetNodes.keys();
      var next = keys.next();
      while (next.done === false) {
        var targetId = next.value;
        if (node === _this.targetNodes.get(targetId)) {
          return targetId;
        } else {
          next = keys.next();
        }
      }
      return void 0;
    };
    this.handleTopMoveEndCapture = function(e) {
      _this._isScrolling = false;
      _this.lastTargetTouchFallback = void 0;
      if (!eventShouldEndDrag(e)) {
        return;
      }
      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {
        _this.moveStartSourceIds = void 0;
        return;
      }
      if (e.cancelable)
        e.preventDefault();
      _this._mouseClientOffset = {};
      _this.uninstallSourceNodeRemovalObserver();
      _this.actions.drop();
      _this.actions.endDrag();
    };
    this.handleCancelOnEscape = function(e) {
      if (e.key === "Escape" && _this.monitor.isDragging()) {
        _this._mouseClientOffset = {};
        _this.uninstallSourceNodeRemovalObserver();
        _this.actions.endDrag();
      }
    };
    this.options = new OptionsReader(options, context);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.sourceNodes = new Map();
    this.sourcePreviewNodes = new Map();
    this.sourcePreviewNodeOptions = new Map();
    this.targetNodes = new Map();
    this.listenerTypes = [];
    this._mouseClientOffset = {};
    this._isScrolling = false;
    if (this.options.enableMouseEvents) {
      this.listenerTypes.push(ListenerType.mouse);
    }
    if (this.options.enableTouchEvents) {
      this.listenerTypes.push(ListenerType.touch);
    }
    if (this.options.enableKeyboardEvents) {
      this.listenerTypes.push(ListenerType.keyboard);
    }
  }
  __name(TouchBackendImpl2, "TouchBackendImpl");
  _createClass2(TouchBackendImpl2, [{
    key: "profile",
    value: /* @__PURE__ */ __name(function profile() {
      var _this$dragOverTargetI;
      return {
        sourceNodes: this.sourceNodes.size,
        sourcePreviewNodes: this.sourcePreviewNodes.size,
        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
        targetNodes: this.targetNodes.size,
        dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0
      };
    }, "profile")
  }, {
    key: "document",
    get: /* @__PURE__ */ __name(function get() {
      return this.options.document;
    }, "get")
  }, {
    key: "setup",
    value: /* @__PURE__ */ __name(function setup() {
      if (!this.document) {
        return;
      }
      invariant(!TouchBackendImpl2.isSetUp, "Cannot have two Touch backends at the same time.");
      TouchBackendImpl2.isSetUp = true;
      this.addEventListener(this.document, "start", this.getTopMoveStartHandler());
      this.addEventListener(this.document, "start", this.handleTopMoveStartCapture, true);
      this.addEventListener(this.document, "move", this.handleTopMove);
      this.addEventListener(this.document, "move", this.handleTopMoveCapture, true);
      this.addEventListener(this.document, "end", this.handleTopMoveEndCapture, true);
      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {
        this.addEventListener(this.document, "contextmenu", this.handleTopMoveEndCapture);
      }
      if (this.options.enableKeyboardEvents) {
        this.addEventListener(this.document, "keydown", this.handleCancelOnEscape, true);
      }
    }, "setup")
  }, {
    key: "teardown",
    value: /* @__PURE__ */ __name(function teardown() {
      if (!this.document) {
        return;
      }
      TouchBackendImpl2.isSetUp = false;
      this._mouseClientOffset = {};
      this.removeEventListener(this.document, "start", this.handleTopMoveStartCapture, true);
      this.removeEventListener(this.document, "start", this.handleTopMoveStart);
      this.removeEventListener(this.document, "move", this.handleTopMoveCapture, true);
      this.removeEventListener(this.document, "move", this.handleTopMove);
      this.removeEventListener(this.document, "end", this.handleTopMoveEndCapture, true);
      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {
        this.removeEventListener(this.document, "contextmenu", this.handleTopMoveEndCapture);
      }
      if (this.options.enableKeyboardEvents) {
        this.removeEventListener(this.document, "keydown", this.handleCancelOnEscape, true);
      }
      this.uninstallSourceNodeRemovalObserver();
    }, "teardown")
  }, {
    key: "addEventListener",
    value: /* @__PURE__ */ __name(function addEventListener2(subject, event, handler, capture) {
      var options = supportsPassive ? {
        capture,
        passive: false
      } : capture;
      this.listenerTypes.forEach(function(listenerType) {
        var evt = eventNames[listenerType][event];
        if (evt) {
          subject.addEventListener(evt, handler, options);
        }
      });
    }, "addEventListener")
  }, {
    key: "removeEventListener",
    value: /* @__PURE__ */ __name(function removeEventListener(subject, event, handler, capture) {
      var options = supportsPassive ? {
        capture,
        passive: false
      } : capture;
      this.listenerTypes.forEach(function(listenerType) {
        var evt = eventNames[listenerType][event];
        if (evt) {
          subject.removeEventListener(evt, handler, options);
        }
      });
    }, "removeEventListener")
  }, {
    key: "connectDragSource",
    value: /* @__PURE__ */ __name(function connectDragSource(sourceId, node) {
      var _this2 = this;
      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);
      this.sourceNodes.set(sourceId, node);
      this.addEventListener(node, "start", handleMoveStart);
      return function() {
        _this2.sourceNodes.delete(sourceId);
        _this2.removeEventListener(node, "start", handleMoveStart);
      };
    }, "connectDragSource")
  }, {
    key: "connectDragPreview",
    value: /* @__PURE__ */ __name(function connectDragPreview(sourceId, node, options) {
      var _this3 = this;
      this.sourcePreviewNodeOptions.set(sourceId, options);
      this.sourcePreviewNodes.set(sourceId, node);
      return function() {
        _this3.sourcePreviewNodes.delete(sourceId);
        _this3.sourcePreviewNodeOptions.delete(sourceId);
      };
    }, "connectDragPreview")
  }, {
    key: "connectDropTarget",
    value: /* @__PURE__ */ __name(function connectDropTarget(targetId, node) {
      var _this4 = this;
      if (!this.document) {
        return function() {
        };
      }
      var handleMove = /* @__PURE__ */ __name(function handleMove2(e) {
        if (!_this4.document || !_this4.monitor.isDragging()) {
          return;
        }
        var coords;
        switch (e.type) {
          case eventNames.mouse.move:
            coords = {
              x: e.clientX,
              y: e.clientY
            };
            break;
          case eventNames.touch.move:
            coords = {
              x: e.touches[0].clientX,
              y: e.touches[0].clientY
            };
            break;
        }
        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : void 0;
        var childMatch = droppedOn && node.contains(droppedOn);
        if (droppedOn === node || childMatch) {
          return _this4.handleMove(e, targetId);
        }
      }, "handleMove");
      this.addEventListener(this.document.body, "move", handleMove);
      this.targetNodes.set(targetId, node);
      return function() {
        if (_this4.document) {
          _this4.targetNodes.delete(targetId);
          _this4.removeEventListener(_this4.document.body, "move", handleMove);
        }
      };
    }, "connectDropTarget")
  }, {
    key: "getTopMoveStartHandler",
    value: /* @__PURE__ */ __name(function getTopMoveStartHandler() {
      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {
        return this.handleTopMoveStart;
      }
      return this.handleTopMoveStartDelay;
    }, "getTopMoveStartHandler")
  }, {
    key: "installSourceNodeRemovalObserver",
    value: /* @__PURE__ */ __name(function installSourceNodeRemovalObserver(node) {
      var _this5 = this;
      this.uninstallSourceNodeRemovalObserver();
      this.draggedSourceNode = node;
      this.draggedSourceNodeRemovalObserver = new MutationObserver(function() {
        if (node && !node.parentElement) {
          _this5.resurrectSourceNode();
          _this5.uninstallSourceNodeRemovalObserver();
        }
      });
      if (!node || !node.parentElement) {
        return;
      }
      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {
        childList: true
      });
    }, "installSourceNodeRemovalObserver")
  }, {
    key: "resurrectSourceNode",
    value: /* @__PURE__ */ __name(function resurrectSourceNode() {
      if (this.document && this.draggedSourceNode) {
        this.draggedSourceNode.style.display = "none";
        this.draggedSourceNode.removeAttribute("data-reactid");
        this.document.body.appendChild(this.draggedSourceNode);
      }
    }, "resurrectSourceNode")
  }, {
    key: "uninstallSourceNodeRemovalObserver",
    value: /* @__PURE__ */ __name(function uninstallSourceNodeRemovalObserver() {
      if (this.draggedSourceNodeRemovalObserver) {
        this.draggedSourceNodeRemovalObserver.disconnect();
      }
      this.draggedSourceNodeRemovalObserver = void 0;
      this.draggedSourceNode = void 0;
    }, "uninstallSourceNodeRemovalObserver")
  }]);
  return TouchBackendImpl2;
}();

// ../.yarn/cache/react-dnd-touch-backend-npm-14.0.0-89f54f09d4-bb77623963.zip/node_modules/react-dnd-touch-backend/dist/esm/index.js
var TouchBackend = /* @__PURE__ */ __name(function createBackend(manager) {
  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return new TouchBackendImpl(manager, context, options);
}, "createBackend");
export {
  TouchBackend,
  TouchBackendImpl
};
//# sourceMappingURL=react-dnd-touch-backend.js.map
