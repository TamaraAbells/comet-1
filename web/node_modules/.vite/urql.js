import {
  I,
  M,
  P,
  S,
  T,
  U,
  V,
  import_printer,
  u,
  v,
  x
} from "./chunk.I2JUFTQN.js";
import {
  N,
  createRequest,
  map$1,
  onEnd$1,
  v as v2,
  y
} from "./chunk.QDKH3HXJ.js";
import {
  toPromise$1
} from "./chunk.U6CQNBPC.js";
import {
  A,
  B,
  D,
  Kind,
  filter$1,
  m,
  make$1,
  merge$1,
  share$1,
  takeUntil$1,
  u as u2,
  w,
  z
} from "./chunk.2QC3HF4U.js";
import {
  H,
  m as m2
} from "./chunk.ZKDFWQVH.js";
import "./chunk.WZSZG6XK.js";
import "./chunk.K5PCYWJY.js";
import "./chunk.BROQQF2P.js";
import {
  __toModule
} from "./chunk.5JD2HCIV.js";
import "./chunk.FNFVRXQK.js";
import {
  require_react
} from "./chunk.BD4KNU7W.js";
import "./chunk.MXG56MB2.js";
import "./chunk.5OSL2VXB.js";
import {
  __name
} from "./chunk.C4F35LU4.js";

// ../.yarn/cache/wonka-npm-4.0.15-716683372a-df4fd51c15.zip/node_modules/wonka/dist/wonka.mjs
function takeWhile$1(a) {
  return function(b) {
    return function(c) {
      let d = m2, e = false;
      return b(function(b2) {
        typeof b2 == "number" ? e || (e = true, c(0)) : b2.tag ? e || (a(b2[0]) ? c(b2) : (e = true, c(0), d(1))) : (d = b2[0], c(b2));
      });
    };
  };
}
__name(takeWhile$1, "takeWhile$1");

// ../.yarn/$$virtual/@urql-core-virtual-9f6d4998ab/0/cache/@urql-core-npm-2.0.0-7689f44c21-43890e0dc9.zip/node_modules/@urql/core/dist/urql-core.mjs
function A2(a, b, c) {
  var d, e, f;
  for (d = 0; d < c.length; d++) {
    if (c[d].kind === Kind.FRAGMENT_DEFINITION) {
      e = c[d].name.value, f = v2(c[d]);
      a.has(e) ? a.get(e) !== f && console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + e + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.") : (a.set(e, f), b.push(c[d]));
    } else {
      b.push(c[d]);
    }
  }
}
__name(A2, "A");
function B2(a) {
  return (a = a.kind) !== "subscription" && a !== "query";
}
__name(B2, "B");
function C(a) {
  return a.path || a.extensions ? {
    message: a.message,
    path: a.path,
    extensions: a.extensions
  } : a.message;
}
__name(C, "C");
function K(a) {
  return console.log("[Exchange debug]: Completed operation: ", a);
}
__name(K, "K");
function L(a) {
  return console.log("[Exchange debug]: Incoming operation: ", a);
}
__name(L, "L");
function createClient(a) {
  return new V(a);
}
__name(createClient, "createClient");
function debugExchange(a) {
  var d = a.forward;
  return false ? /* @__PURE__ */ __name(function b(a2) {
    return d(a2);
  }, "b") : /* @__PURE__ */ __name(function c(a2) {
    return H(K)(d(H(L)(a2)));
  }, "c");
}
__name(debugExchange, "debugExchange");
function errorExchange(a) {
  function b(a2) {
    var b2 = a2.error;
    a2 = a2.operation;
    b2 && c(b2, a2);
  }
  __name(b, "b");
  var c = a.onError;
  return function(a2) {
    var c2 = a2.forward;
    return function(a3) {
      return H(b)(c2(a3));
    };
  };
}
__name(errorExchange, "errorExchange");
function gql() {
  var a, b, c, d, e, f, g;
  for (a = arguments, b = new Map(), c = [], d = [], e = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "", f = 1; f < arguments.length; f++) {
    (g = a[f]) && g.definitions ? d.push.apply(d, g.definitions) : e += g;
    e += a[0][f];
  }
  A2(b, c, y(e).definitions);
  A2(b, c, d);
  return y({
    kind: Kind.DOCUMENT,
    definitions: c
  });
}
__name(gql, "gql");
function ssrExchange(a) {
  function b(b2) {
    var c2 = b2.client, l = b2.forward;
    return function(b3) {
      var e2 = a && typeof a.isClient == "boolean" ? !!a.isClient : !c2.suspense, h2 = share$1(b3);
      b3 = l(filter$1(f)(h2));
      h2 = map$1(g)(filter$1(m3)(h2));
      e2 ? h2 = H(d)(h2) : b3 = H(q)(b3);
      return merge$1([b3, h2]);
    };
  }
  __name(b, "b");
  function c(a2) {
    return !B2(a2) && k[a2.key] !== void 0;
  }
  __name(c, "c");
  function d(a2) {
    h.push(a2.operation.key);
    h.length === 1 && Promise.resolve().then(e);
  }
  __name(d, "d");
  function e() {
    for (var a2; a2 = h.shift(); ) {
      delete k[a2];
    }
  }
  __name(e, "e");
  function f(a2) {
    return !c(a2);
  }
  __name(f, "f");
  function g(a2) {
    var b2 = k[a2.key], c2 = b2.error;
    return {
      operation: a2,
      data: (b2 = b2.data) ? JSON.parse(b2) : void 0,
      extensions: void 0,
      error: c2 ? new m({
        networkError: c2.networkError ? Error(c2.networkError) : void 0,
        graphQLErrors: c2.graphQLErrors && c2.graphQLErrors.length ? c2.graphQLErrors : void 0
      }) : void 0
    };
  }
  __name(g, "g");
  function m3(a2) {
    return c(a2);
  }
  __name(m3, "m");
  function q(a2) {
    var c2, d2, b2 = a2.operation;
    if (!B2(b2)) {
      c2 = a2.data;
      a2 = a2.error;
      d2 = {};
      c2 !== void 0 && (d2.data = JSON.stringify(c2));
      a2 && (d2.error = {
        graphQLErrors: a2.graphQLErrors.map(C)
      }, a2.networkError && (d2.error.networkError = "" + a2.networkError));
      k[b2.key] = d2;
    }
  }
  __name(q, "q");
  var k = {}, h = [];
  b.restoreData = function(a2) {
    return B(k, a2);
  };
  b.extractData = function() {
    return B({}, k);
  };
  a && a.initialState && b.restoreData(a.initialState);
  return b;
}
__name(ssrExchange, "ssrExchange");
function subscriptionExchange(a) {
  function b(a2) {
    return (a2 = a2.kind) === "subscription" || !!d && (a2 === "query" || a2 === "mutation");
  }
  __name(b, "b");
  var c = a.forwardSubscription, d = a.enableAllOperations;
  return function(a2) {
    function d2(a3) {
      var b2 = c({
        key: a3.key.toString(36),
        query: (0, import_printer.print)(a3.query),
        variables: a3.variables,
        context: B({}, a3.context)
      });
      return make$1(function(c2) {
        function d3(b3) {
          return f(z(a3, b3));
        }
        __name(d3, "d");
        function e2(b3) {
          return f(A(a3, b3));
        }
        __name(e2, "e");
        function h() {
          g || (g = true, a3.kind === "subscription" && m3.reexecuteOperation(x("teardown", a3, a3.context)), l());
        }
        __name(h, "h");
        var k2, f = c2.next, l = c2.complete, g = false;
        Promise.resolve().then(function() {
          g || (k2 = b2.subscribe({
            next: d3,
            error: e2,
            complete: h
          }));
        });
        return function() {
          g = true;
          k2 && k2.unsubscribe();
        };
      });
    }
    __name(d2, "d");
    function e(a3) {
      return !k(a3);
    }
    __name(e, "e");
    var m3 = a2.client, q = a2.forward, k = b;
    return function(a3) {
      var c2, b2 = share$1(a3);
      a3 = D(function(a4) {
        var c3 = a4.key, e2 = filter$1(function(a5) {
          return a5.kind === "teardown" && a5.key === c3;
        })(b2);
        return takeUntil$1(e2)(d2(a4));
      })(filter$1(k)(b2));
      c2 = q(filter$1(e)(b2));
      return merge$1([a3, c2]);
    };
  };
}
__name(subscriptionExchange, "subscriptionExchange");

// ../.yarn/$$virtual/urql-virtual-14b630cc4d/0/cache/urql-npm-2.0.1-bb56572cf7-5f6a246e7d.zip/node_modules/urql/dist/urql.es.js
var import_react = __toModule(require_react());
function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}
__name(_extends, "_extends");
function useMutation(query) {
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: false,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions,
        operation: result.operation
      });
    }
    return result;
  }
  __name(_ref, "_ref");
  function _ref2() {
    isMounted.current = false;
  }
  __name(_ref2, "_ref2");
  var isMounted = (0, import_react.useRef)(true), client = useClient(), ref = (0, import_react.useState)(initialState), state = ref[0], setState = ref[1], executeMutation = (0, import_react.useCallback)(function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: true
    }));
    return toPromise$1(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);
  }, [client, query, setState]);
  (0, import_react.useEffect)(function() {
    return _ref2;
  }, []);
  return [state, executeMutation];
}
__name(useMutation, "useMutation");
function useRequest(query, variables) {
  var prev = (0, import_react.useRef)(void 0);
  return (0, import_react.useMemo)(function() {
    var request = createRequest(query, variables);
    if (prev.current !== void 0 && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }, [query, variables]);
}
__name(useRequest, "useRequest");
function useQuery(args) {
  function _ref(result) {
    cache.set(request.key, result);
  }
  __name(_ref, "_ref");
  var client = useClient(), cache = getCacheForClient(client), suspense = isSuspense(client, args.context), request = useRequest(args.query, args.variables), source = (0, import_react.useMemo)(function() {
    if (args.pause) {
      return null;
    }
    var source2 = client.executeQuery(request, _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context));
    return suspense ? H(_ref)(source2) : source2;
  }, [client, request, suspense, args.pause, args.requestPolicy, args.context]), getSnapshot = (0, import_react.useCallback)(function(source2, suspense2) {
    var result, resolve, subscription, promise;
    if (!source2) {
      return {
        fetching: false
      };
    }
    if (!(result = cache.get(request.key))) {
      subscription = N(/* @__PURE__ */ __name(function _ref2(_result) {
        result = _result;
        if (resolve) {
          resolve(result);
        }
      }, "_ref2"))(takeWhile$1(/* @__PURE__ */ __name(function _ref3() {
        return suspense2 && !resolve || !result;
      }, "_ref3"))(source2));
      if (result == null && suspense2) {
        promise = new Promise(/* @__PURE__ */ __name(function _ref4(_resolve) {
          resolve = _resolve;
        }, "_ref4"));
        cache.set(request.key, promise);
        throw promise;
      } else {
        subscription.unsubscribe();
      }
    } else if (suspense2 && result != null && "then" in result) {
      throw result;
    }
    return result || {
      fetching: true
    };
  }, [request]), deps = [client, request, args.requestPolicy, args.context, args.pause], ref = (0, import_react.useState)(function() {
    currentInit = true;
    try {
      return [source, computeNextState(initialState, getSnapshot(source, suspense)), deps];
    } finally {
      currentInit = false;
    }
  }), state = ref[0], setState = ref[1], currentResult = state[1];
  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps]);
  }
  (0, import_react.useEffect)(function() {
    var subscription, source2 = state[0], request2 = state[2][1], hasResult = false, updateResult = /* @__PURE__ */ __name(function(result) {
      hasResult = true;
      if (!currentInit) {
        setState(/* @__PURE__ */ __name(function _ref5(state2) {
          var nextResult = computeNextState(state2[1], result);
          return state2[1] !== nextResult ? [state2[0], nextResult, state2[2]] : state2;
        }, "_ref5"));
      }
    }, "updateResult");
    if (source2) {
      subscription = N(updateResult)(onEnd$1(/* @__PURE__ */ __name(function _ref6() {
        updateResult({
          fetching: false
        });
      }, "_ref6"))(source2));
      if (!hasResult) {
        updateResult({
          fetching: true
        });
      }
      return /* @__PURE__ */ __name(function _ref7() {
        cache.dispose(request2.key);
        subscription.unsubscribe();
      }, "_ref7");
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [cache, state[0], state[2][1]]);
  return [currentResult, (0, import_react.useCallback)(function(opts) {
    var context = _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context, opts), source2 = client.executeQuery(request, context);
    setState(function(state2) {
      var snapshot = context.requestPolicy !== "network-only" ? getSnapshot(source2, false) : {
        fetching: true
      }, nextResult = computeNextState(state2[1], snapshot);
      return state2[1] !== nextResult ? [source2, nextResult, state2[2]] : state2;
    });
  }, [client, request, getSnapshot, args.requestPolicy, args.context])];
}
__name(useQuery, "useQuery");
function useSubscription(args, handler) {
  function _ref(result) {
    setState(function(state2) {
      var nextResult = computeNextState(state2[1], result);
      if (state2[1] === nextResult) {
        return state2;
      }
      if (handlerRef.current && state2[1].data !== nextResult.data) {
        nextResult.data = handlerRef.current(state2[1].data, nextResult.data);
      }
      return [state2[0], nextResult, state2[2]];
    });
  }
  __name(_ref, "_ref");
  var source, deps, ref, state, setState, currentResult, client = useClient(), request = useRequest(args.query, args.variables), handlerRef = (0, import_react.useRef)(handler);
  handlerRef.current = handler;
  source = (0, import_react.useMemo)(function() {
    return !args.pause ? client.executeSubscription(request, args.context) : null;
  }, [client, request, args.pause, args.context]);
  deps = [client, request, args.context, args.pause];
  ref = (0, import_react.useState)(function() {
    return [source, _extends({}, initialState, {
      fetching: !!source
    }), deps];
  });
  setState = ref[1];
  currentResult = (state = ref[0])[1];
  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], {
      fetching: !!source
    }), deps]);
  }
  (0, import_react.useEffect)(function() {
    var updateResult = _ref;
    if (state[0]) {
      return N(updateResult)(onEnd$1(/* @__PURE__ */ __name(function _ref2() {
        updateResult({
          fetching: false
        });
      }, "_ref2"))(state[0])).unsubscribe;
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [state[0]]);
  return [currentResult, (0, import_react.useCallback)(function(opts) {
    var source2 = client.executeSubscription(request, _extends({}, args.context, opts));
    setState(function(state2) {
      return [source2, state2[1], state2[2]];
    });
  }, [client, args.context, request])];
}
__name(useSubscription, "useSubscription");
function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children(_extends({}, mutation[0], {
    executeMutation: mutation[1]
  }));
}
__name(Mutation, "Mutation");
function Query(props) {
  var query = useQuery(props);
  return props.children(_extends({}, query[0], {
    executeQuery: query[1]
  }));
}
__name(Query, "Query");
function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children(_extends({}, subscription[0], {
    executeSubscription: subscription[1]
  }));
}
__name(Subscription, "Subscription");
var defaultClient;
var Context;
var Provider;
var Consumer;
var hasWarnedAboutDefault;
var useClient;
var initialState;
var isShallowDifferent;
var computeNextState;
var hasDepsChanged;
var getCacheForClient;
var isSuspense;
var currentInit;
defaultClient = createClient({
  url: "/graphql"
});
Provider = (Context = (0, import_react.createContext)(defaultClient)).Provider;
Consumer = Context.Consumer;
hasWarnedAboutDefault = false;
useClient = /* @__PURE__ */ __name(function() {
  var client = (0, import_react.useContext)(Context);
  if (client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = true;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
}, "useClient");
initialState = {
  fetching: false,
  stale: false,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};
isShallowDifferent = /* @__PURE__ */ __name(function(a, b) {
  var x2, x$1;
  if (typeof a != "object" || typeof b != "object") {
    return a !== b;
  }
  for (x2 in a) {
    if (!(x2 in b)) {
      return true;
    }
  }
  for (x$1 in b) {
    if (a[x$1] !== b[x$1]) {
      return true;
    }
  }
  return false;
}, "isShallowDifferent");
computeNextState = /* @__PURE__ */ __name(function(prevState, result) {
  var newState = _extends({}, prevState, result, {
    fetching: !!result.fetching,
    stale: !!result.stale
  });
  return isShallowDifferent(prevState, newState) ? newState : prevState;
}, "computeNextState");
hasDepsChanged = /* @__PURE__ */ __name(function(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    if (a[i] !== b[i]) {
      return true;
    }
  }
  return false;
}, "hasDepsChanged");
getCacheForClient = /* @__PURE__ */ __name(function(client) {
  var reclaim, map;
  if (!client._react) {
    reclaim = new Set();
    map = new Map();
    if (client.operations$) {
      N(/* @__PURE__ */ __name(function _ref(operation) {
        if (operation.kind === "teardown" && reclaim.has(operation.key)) {
          reclaim.delete(operation.key);
          map.delete(operation.key);
        }
      }, "_ref"))(client.operations$);
    }
    client._react = {
      get: /* @__PURE__ */ __name(function _get(key) {
        return map.get(key);
      }, "_get"),
      set: /* @__PURE__ */ __name(function _set(key, value) {
        reclaim.delete(key);
        map.set(key, value);
      }, "_set"),
      dispose: /* @__PURE__ */ __name(function _dispose(key) {
        reclaim.add(key);
      }, "_dispose")
    };
  }
  return client._react;
}, "getCacheForClient");
isSuspense = /* @__PURE__ */ __name(function(client, context) {
  return client.suspense && (!context || context.suspense !== false);
}, "isSuspense");
currentInit = false;
export {
  V as Client,
  m as CombinedError,
  Consumer,
  Context,
  Mutation,
  Provider,
  Query,
  Subscription,
  I as cacheExchange,
  T as composeExchanges,
  createClient,
  createRequest,
  debugExchange,
  M as dedupExchange,
  U as defaultExchanges,
  errorExchange,
  S as fallbackExchangeIO,
  P as fetchExchange,
  u as formatDocument,
  w as getOperationName,
  gql,
  A as makeErrorResult,
  x as makeOperation,
  z as makeResult,
  v as maskTypename,
  ssrExchange,
  u2 as stringifyVariables,
  subscriptionExchange,
  useClient,
  useMutation,
  useQuery,
  useSubscription
};
//# sourceMappingURL=urql.js.map
