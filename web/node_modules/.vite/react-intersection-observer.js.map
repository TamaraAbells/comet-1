{
  "version": 3,
  "sources": ["../../../.yarn/$$virtual/react-intersection-observer-virtual-7ba936836d/0/cache/react-intersection-observer-npm-8.31.0-f45da58044-cf71521d31.zip/node_modules/react-intersection-observer/react-intersection-observer.m.js", "dep:react-intersection-observer"],
  "sourcesContent": ["import { createElement, Component, useRef, useState, useCallback, useEffect } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar ObserverMap = new Map();\nvar RootIds = new Map();\nvar rootId = 0;\n/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */\n\nfunction getRootId(root) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */\n\n\nfunction optionsToId(options) {\n  return Object.keys(options).sort().filter(function (key) {\n    return options[key] !== undefined;\n  }).map(function (key) {\n    return key + \"_\" + (key === 'root' ? getRootId(options.root) : options[key]);\n  }).toString();\n}\n\nfunction createObserver(options) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  var id = optionsToId(options);\n  var instance = ObserverMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    var elements = new Map();\n    var thresholds;\n    var observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var _elements$get;\n\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        var inView = entry.isIntersecting && thresholds.some(function (threshold) {\n          return entry.intersectionRatio >= threshold;\n        }); // @ts-ignore support IntersectionObserver v2\n\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(function (callback) {\n          callback(inView, entry);\n        });\n      });\n    }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options\n\n    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);\n    instance = {\n      id: id,\n      observer: observer,\n      elements: elements\n    };\n    ObserverMap.set(id, instance);\n  }\n\n  return instance;\n}\n\nfunction observe(element, callback, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!element) return function () {}; // An observer with the same options can be reused, so lets use this fact\n\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements; // Register the callback listener for this element\n\n\n  var callbacks = elements.get(element) || [];\n\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements[\"delete\"](element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      ObserverMap[\"delete\"](id);\n    }\n  };\n}\n\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\r\n * Monitors scroll, and triggers the children function with updated props\r\n */\n\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.node = null;\n    _this._unobserveCb = null;\n\n    _this.handleNode = function (node) {\n      if (_this.node) {\n        // Clear the old observer, before we start observing a new element\n        _this.unobserve();\n\n        if (!node && !_this.props.triggerOnce && !_this.props.skip) {\n          // Reset the state if we get a new node, and we aren't ignoring updates\n          _this.setState({\n            inView: !!_this.props.initialInView,\n            entry: undefined\n          });\n        }\n      }\n\n      _this.node = node ? node : null;\n\n      _this.observeNode();\n    };\n\n    _this.handleChange = function (inView, entry) {\n      if (inView && _this.props.triggerOnce) {\n        // If `triggerOnce` is true, we should stop observing the element.\n        _this.unobserve();\n      }\n\n      if (!isPlainChildren(_this.props)) {\n        // Store the current State, so we can pass it to the children in the next render update\n        // There's no reason to update the state for plain children, since it's not used in the rendering.\n        _this.setState({\n          inView: inView,\n          entry: entry\n        });\n      }\n\n      if (_this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        _this.props.onChange(inView, entry);\n      }\n    };\n\n    _this.state = {\n      inView: !!props.initialInView,\n      entry: undefined\n    };\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n      this.unobserve();\n      this.observeNode();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node || this.props.skip) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        trackVisibility = _this$props.trackVisibility,\n        delay = _this$props.delay;\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin,\n      // @ts-ignore\n      trackVisibility: trackVisibility,\n      // @ts-ignore\n      delay: delay\n    });\n  };\n\n  _proto.unobserve = function unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n\n      this._unobserveCb = null;\n    }\n  };\n\n  _proto.render = function render() {\n    if (!isPlainChildren(this.props)) {\n      var _this$state = this.state,\n          inView = _this$state.inView,\n          entry = _this$state.entry;\n      return this.props.children({\n        inView: inView,\n        entry: entry,\n        ref: this.handleNode\n      });\n    }\n\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        as = _this$props2.as,\n        tag = _this$props2.tag,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"as\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\", \"skip\", \"trackVisibility\", \"delay\", \"initialInView\"]);\n\n    return /*#__PURE__*/createElement(as || tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\nInView.displayName = 'InView';\nInView.defaultProps = {\n  threshold: 0,\n  triggerOnce: false,\n  initialInView: false\n};\n\nfunction useInView(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      threshold = _ref.threshold,\n      delay = _ref.delay,\n      trackVisibility = _ref.trackVisibility,\n      rootMargin = _ref.rootMargin,\n      root = _ref.root,\n      triggerOnce = _ref.triggerOnce,\n      skip = _ref.skip,\n      initialInView = _ref.initialInView;\n\n  var unobserve = useRef();\n\n  var _React$useState = useState({\n    inView: !!initialInView\n  }),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var setRef = useCallback(function (node) {\n    if (unobserve.current !== undefined) {\n      unobserve.current();\n      unobserve.current = undefined;\n    } // Skip creating the observer\n\n\n    if (skip) return;\n\n    if (node) {\n      unobserve.current = observe(node, function (inView, entry) {\n        setState({\n          inView: inView,\n          entry: entry\n        });\n\n        if (entry.isIntersecting && triggerOnce && unobserve.current) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve.current();\n          unobserve.current = undefined;\n        }\n      }, {\n        root: root,\n        rootMargin: rootMargin,\n        threshold: threshold,\n        // @ts-ignore\n        trackVisibility: trackVisibility,\n        // @ts-ignore\n        delay: delay\n      });\n    }\n  }, // We break the rule here, because we aren't including the actual `threshold` variable\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [// If the threshold is an array, convert it to a string so it won't change between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  Array.isArray(threshold) ? threshold.toString() : threshold, root, rootMargin, triggerOnce, skip, trackVisibility, delay]);\n  /* eslint-disable-next-line */\n\n  useEffect(function () {\n    if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView\n      });\n    }\n  });\n  var result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.\n\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n  return result;\n}\n\nexport default InView;\nexport { InView, useInView };\n//# sourceMappingURL=react-intersection-observer.m.js.map\n", "import d from \"../.yarn/$$virtual/react-intersection-observer-virtual-7ba936836d/0/cache/react-intersection-observer-npm-8.31.0-f45da58044-cf71521d31.zip/node_modules/react-intersection-observer/react-intersection-observer.m.js\";export default d;\nexport * from \"../.yarn/$$virtual/react-intersection-observer-virtual-7ba936836d/0/cache/react-intersection-observer-npm-8.31.0-f45da58044-cf71521d31.zip/node_modules/react-intersection-observer/react-intersection-observer.m.js\""],
  "mappings": "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",
  "names": []
}
