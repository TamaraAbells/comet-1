import {
  __toModule
} from "./chunk.5JD2HCIV.js";
import "./chunk.FNFVRXQK.js";
import {
  require_react
} from "./chunk.BD4KNU7W.js";
import "./chunk.MXG56MB2.js";
import "./chunk.5OSL2VXB.js";
import {
  __name
} from "./chunk.C4F35LU4.js";

// ../.yarn/$$virtual/react-hook-form-virtual-6dfcb61800/0/cache/react-hook-form-npm-7.0.0-rc.8-3c83c2425f-c3ea1a24a1.zip/node_modules/react-hook-form/dist/index.esm.js
var React = __toModule(require_react());
var isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
var isNullOrUndefined = /* @__PURE__ */ __name((value) => value == null, "isNullOrUndefined");
var isObjectType = /* @__PURE__ */ __name((value) => typeof value === "object", "isObjectType");
var isObject = /* @__PURE__ */ __name((value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date), "isObject");
var compact = /* @__PURE__ */ __name((value) => value.filter(Boolean), "compact");
var get = /* @__PURE__ */ __name((obj = {}, path, defaultValue) => {
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], obj);
  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;
}, "get");
var isKey = /* @__PURE__ */ __name((value) => /^\w*$/.test(value), "isKey");
var stringToPath = /* @__PURE__ */ __name((input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/)), "stringToPath");
function set(object, path, value) {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index < length) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
}
__name(set, "set");
var omit = /* @__PURE__ */ __name((source, key) => {
  const copy = Object.assign({}, source);
  delete copy[key];
  return copy;
}, "omit");
var focusFieldBy = /* @__PURE__ */ __name((fields, callback, fieldsNames) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const _f = field._f;
      const current = omit(field, "_f");
      if (_f && callback(_f.name)) {
        if (_f.ref.focus && isUndefined(_f.ref.focus())) {
          break;
        } else if (_f.refs) {
          _f.refs[0].focus();
          break;
        }
      } else if (isObject(current)) {
        focusFieldBy(current, callback);
      }
    }
  }
}, "focusFieldBy");
var isPrimitive = /* @__PURE__ */ __name((value) => isNullOrUndefined(value) || !isObjectType(value), "isPrimitive");
function deepMerge(target, source) {
  if (isPrimitive(target) || isPrimitive(source)) {
    return source;
  }
  for (const key in source) {
    const targetValue = target[key];
    const sourceValue = source[key];
    try {
      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;
    } catch (_a) {
    }
  }
  return target;
}
__name(deepMerge, "deepMerge");
function deepEqual(object1, object2, isErrorObject) {
  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {
    return object1 === object2;
  }
  if (!React.isValidElement(object1)) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (const key of keys1) {
      const val1 = object1[key];
      if (!(isErrorObject && key === "ref")) {
        const val2 = object2[key];
        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {
          return false;
        }
      }
    }
  }
  return true;
}
__name(deepEqual, "deepEqual");
function setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {
  let index = -1;
  while (++index < values.length) {
    for (const key in values[index]) {
      if (Array.isArray(values[index][key])) {
        !dirtyFields[index] && (dirtyFields[index] = {});
        dirtyFields[index][key] = [];
        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);
      } else {
        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {[key]: true});
      }
    }
    parentNode && !dirtyFields.length && delete parentNode[parentName];
  }
  return dirtyFields;
}
__name(setDirtyFields, "setDirtyFields");
var setFieldArrayDirtyFields = /* @__PURE__ */ __name((values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length))), "setFieldArrayDirtyFields");
var isEmptyObject = /* @__PURE__ */ __name((value) => isObject(value) && !Object.keys(value).length, "isEmptyObject");
var EVENTS = {
  BLUR: "blur",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var SELECT = "select";
var UNDEFINED = "undefined";
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var shouldRenderFormState = /* @__PURE__ */ __name((formState, readFormStateRef, isRoot) => isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(readFormStateRef).length || Object.keys(formState).find((key) => readFormStateRef[key] === (isRoot ? VALIDATION_MODE.all : true)), "shouldRenderFormState");
var getFieldsValues = /* @__PURE__ */ __name((fieldsRef, defaultValuesRef = {current: {}}, output = {}) => {
  for (const name in fieldsRef.current) {
    const field = fieldsRef.current[name];
    if (field) {
      const _f = field._f;
      const current = omit(field, "_f");
      set(output, name, _f ? _f.ref.disabled || _f.refs && _f.refs.every((ref) => ref.disabled) ? void 0 : _f.value : Array.isArray(field) ? [] : {});
      if (current) {
        getFieldsValues({
          current
        }, defaultValuesRef, output[name]);
      }
    }
  }
  return Object.assign(Object.assign({}, defaultValuesRef.current), output);
}, "getFieldsValues");
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = /* @__PURE__ */ __name((options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn, "getRadioValue");
var getMultipleSelectValue = /* @__PURE__ */ __name((options) => [...options].filter(({selected}) => selected).map(({value}) => value), "getMultipleSelectValue");
var isRadioInput = /* @__PURE__ */ __name((element) => element.type === "radio", "isRadioInput");
var isFileInput = /* @__PURE__ */ __name((element) => element.type === "file", "isFileInput");
var isCheckBoxInput = /* @__PURE__ */ __name((element) => element.type === "checkbox", "isCheckBoxInput");
var isMultipleSelect = /* @__PURE__ */ __name((element) => element.type === `${SELECT}-multiple`, "isMultipleSelect");
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = {value: true, isValid: true};
var getCheckboxValue = /* @__PURE__ */ __name((options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return {value: values, isValid: !!values.length};
    }
    return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) ? validResult : {value: options[0].value, isValid: true} : validResult : defaultResult;
  }
  return defaultResult;
}, "getCheckboxValue");
var getFieldValueAs = /* @__PURE__ */ __name((value, {valueAsNumber, valueAsDate, setValueAs}) => valueAsNumber ? value === "" ? NaN : +value : valueAsDate ? new Date(value) : setValueAs ? setValueAs(value) : value, "getFieldValueAs");
function getFieldValue(field) {
  if (field && field._f) {
    const ref = field._f.ref;
    if (ref.disabled) {
      return;
    }
    if (isFileInput(ref)) {
      return ref.files;
    }
    if (isRadioInput(ref)) {
      return getRadioValue(field._f.refs).value;
    }
    if (isMultipleSelect(ref)) {
      return getMultipleSelectValue(ref.options);
    }
    if (isCheckBoxInput(ref)) {
      return getCheckboxValue(field._f.refs).value;
    }
    return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);
  }
}
__name(getFieldValue, "getFieldValue");
var isErrorStateChanged = /* @__PURE__ */ __name(({errors, name, error, validFields, fieldsWithValidation}) => {
  const isValid = isUndefined(error);
  const previousError = get(errors, name);
  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);
}, "isErrorStateChanged");
var isRegex = /* @__PURE__ */ __name((value) => value instanceof RegExp, "isRegex");
var getValueAndMessage = /* @__PURE__ */ __name((validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
}, "getValueAndMessage");
var isString = /* @__PURE__ */ __name((value) => typeof value === "string", "isString");
var isFunction = /* @__PURE__ */ __name((value) => typeof value === "function", "isFunction");
var isBoolean = /* @__PURE__ */ __name((value) => typeof value === "boolean", "isBoolean");
var isMessage = /* @__PURE__ */ __name((value) => isString(value) || React.isValidElement(value), "isMessage");
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
__name(getValidateError, "getValidateError");
var appendErrors = /* @__PURE__ */ __name((name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {[type]: message || true})}) : {}, "appendErrors");
var validateField = /* @__PURE__ */ __name(async ({_f: {ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue}}, validateAllFieldCriteria) => {
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox = isRadio || isCheckBox;
  const isEmpty = !inputValue || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = /* @__PURE__ */ __name((exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = Object.assign({
      type: exceedMax ? maxType : minType,
      message,
      ref
    }, appendErrorsCurry(exceedMax ? maxType : minType, message));
  }, "getMinMaxMessage");
  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const {value, message} = isMessage(required) ? {value: !!required, message: required} : getValueAndMessage(required);
    if (value) {
      error[name] = Object.assign({type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref}, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));
      if (!validateAllFieldCriteria) {
        return error;
      }
    }
  }
  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && inputValue !== "") {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max);
    const minOutput = getValueAndMessage(min);
    if (!isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || parseFloat(inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      if (isString(maxOutput.value)) {
        exceedMax = valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value)) {
        exceedMin = valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        return error;
      }
    }
  }
  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        return error;
      }
    }
  }
  if (isString(inputValue) && pattern && !isEmpty) {
    const {value: patternValue, message} = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !patternValue.test(inputValue)) {
      error[name] = Object.assign({
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref
      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));
      if (!validateAllFieldCriteria) {
        return error;
      }
    }
  }
  if (validate) {
    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;
    if (isFunction(validate)) {
      const result = await validate(inputValue);
      const validateError = getValidateError(result, validateRef);
      if (validateError) {
        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const [key, validateFunction] of Object.entries(validate)) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateResult = await validateFunction(inputValue);
        const validateError = getValidateError(validateResult, validateRef, key);
        if (validateError) {
          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = Object.assign({ref: validateRef}, validationResult);
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  return error;
}, "validateField");
var skipValidation = /* @__PURE__ */ __name(({isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll}) => {
  if (isOnAll) {
    return false;
  } else if (!isSubmitted && isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {
    return isBlurEvent;
  }
  return true;
}, "skipValidation");
var getNodeParentName = /* @__PURE__ */ __name((name) => name.substring(0, name.search(/.\d/)) || name, "getNodeParentName");
var getProxyFormState = /* @__PURE__ */ __name((isProxyEnabled2, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled2 ? new Proxy(formState, {
  get: (obj, prop) => {
    if (prop in obj) {
      if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {
        readFormStateRef.current[prop] = isRoot ? VALIDATION_MODE.all : true;
      }
      localReadFormStateRef && (localReadFormStateRef.current[prop] = true);
      return obj[prop];
    }
    return void 0;
  }
}) : formState, "getProxyFormState");
var Subscription = class {
  constructor() {
    this.tearDowns = [];
  }
  add(tearDown) {
    this.tearDowns.push(tearDown);
  }
  unsubscribe() {
    for (const teardown of this.tearDowns) {
      teardown();
    }
    this.tearDowns = [];
  }
};
__name(Subscription, "Subscription");
var Subscriber = class {
  constructor(observer, subscription) {
    this.observer = observer;
    this.closed = false;
    subscription.add(() => this.closed = true);
  }
  next(value) {
    if (!this.closed) {
      this.observer.next(value);
    }
  }
};
__name(Subscriber, "Subscriber");
var Subject = class {
  constructor() {
    this.observers = [];
  }
  next(value) {
    for (const observer of this.observers) {
      observer.next(value);
    }
  }
  subscribe(observer) {
    const subscription = new Subscription();
    const subscriber = new Subscriber(observer, subscription);
    this.observers.push(subscriber);
    return subscription;
  }
  unsubscribe() {
    this.observers = [];
  }
};
__name(Subject, "Subject");
var isWeb = typeof window !== UNDEFINED && typeof window.HTMLElement !== UNDEFINED && typeof document !== UNDEFINED;
var isProxyEnabled = isWeb ? "Proxy" in window : typeof Proxy !== UNDEFINED;
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
__name(baseGet, "baseGet");
function unset(object, path) {
  const updatePath = isKey(path) ? [path] : stringToPath(path);
  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);
  const key = updatePath[updatePath.length - 1];
  let previousObjRef;
  if (childObject) {
    delete childObject[key];
  }
  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
    let index = -1;
    let objectRef;
    const currentPaths = updatePath.slice(0, -(k + 1));
    const currentPathsLength = currentPaths.length - 1;
    if (k > 0) {
      previousObjRef = object;
    }
    while (++index < currentPaths.length) {
      const item = currentPaths[index];
      objectRef = objectRef ? objectRef[item] : object[item];
      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter((data) => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {
        previousObjRef ? delete previousObjRef[item] : delete object[item];
      }
      previousObjRef = objectRef;
    }
  }
  return object;
}
__name(unset, "unset");
var getValidationModes = /* @__PURE__ */ __name((mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
}), "getValidationModes");
var isRadioOrCheckboxFunction = /* @__PURE__ */ __name((ref) => isRadioInput(ref) || isCheckBoxInput(ref), "isRadioOrCheckboxFunction");
var isHTMLElement = /* @__PURE__ */ __name((value) => value instanceof HTMLElement, "isHTMLElement");
function getFields(fieldsNames, fieldsRefs) {
  const currentFields = {};
  for (const name of fieldsNames) {
    const field = get(fieldsRefs, name);
    if (field) {
      !isKey(name) ? set(currentFields, name, field._f) : currentFields[name] = field._f;
    }
  }
  return currentFields;
}
__name(getFields, "getFields");
var isWindowUndefined = typeof window === UNDEFINED;
function useForm({mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, criteriaMode} = {}) {
  const fieldsRef = React.useRef({});
  const fieldsNamesRef = React.useRef(new Set());
  const formStateSubjectRef = React.useRef(new Subject());
  const watchSubjectRef = React.useRef(new Subject());
  const controllerSubjectRef = React.useRef(new Subject());
  const fieldArraySubjectRef = React.useRef(new Subject());
  const fieldArrayDefaultValuesRef = React.useRef({});
  const watchFieldsRef = React.useRef(new Set());
  const isMountedRef = React.useRef(false);
  const fieldsWithValidationRef = React.useRef({});
  const validFieldsRef = React.useRef({});
  const defaultValuesRef = React.useRef(defaultValues);
  const isWatchAllRef = React.useRef(false);
  const contextRef = React.useRef(context);
  const resolverRef = React.useRef(resolver);
  const fieldArrayNamesRef = React.useRef(new Set());
  const validationMode = getValidationModes(mode);
  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;
  const [formState, setFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touchedFields: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: !validationMode.isOnSubmit,
    errors: {}
  });
  const readFormStateRef = React.useRef({
    isDirty: !isProxyEnabled,
    dirtyFields: !isProxyEnabled,
    touchedFields: !isProxyEnabled,
    isValidating: !isProxyEnabled,
    isValid: !isProxyEnabled,
    errors: !isProxyEnabled
  });
  const formStateRef = React.useRef(formState);
  contextRef.current = context;
  resolverRef.current = resolver;
  const getIsValid = /* @__PURE__ */ __name(() => formStateRef.current.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors), "getIsValid");
  const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {
    let shouldReRender = shouldRender || isErrorStateChanged({
      errors: formStateRef.current.errors,
      error,
      name,
      validFields: validFieldsRef.current,
      fieldsWithValidation: fieldsWithValidationRef.current
    });
    const previousError = get(formStateRef.current.errors, name);
    if (error) {
      unset(validFieldsRef.current, name);
      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);
      set(formStateRef.current.errors, name, error);
    } else {
      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {
        set(validFieldsRef.current, name, true);
        shouldReRender = shouldReRender || previousError;
      }
      unset(formStateRef.current.errors, name);
    }
    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state) || isWatched) {
      const updatedFormState = Object.assign(Object.assign({}, state), {isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors});
      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);
      formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);
    }
    formStateSubjectRef.current.next({
      isValidating: false
    });
  }, []);
  const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {
    shouldRegister && register(name);
    const _f = get(fieldsRef.current, name, {})._f;
    if (_f) {
      const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue) ? "" : rawValue;
      _f.value = rawValue;
      if (isRadioInput(_f.ref)) {
        (_f.refs || []).forEach((radioRef) => radioRef.checked = radioRef.value === value);
      } else if (isFileInput(_f.ref) && !isString(value)) {
        _f.ref.files = value;
      } else if (isMultipleSelect(_f.ref)) {
        [..._f.ref.options].forEach((selectRef) => selectRef.selected = value.includes(selectRef.value));
      } else if (isCheckBoxInput(_f.ref) && _f.refs) {
        _f.refs.length > 1 ? _f.refs.forEach((checkboxRef) => checkboxRef.checked = Array.isArray(value) ? !!value.find((data) => data === checkboxRef.value) : value === checkboxRef.value) : _f.refs[0].checked = !!value;
      } else {
        _f.ref.value = value;
      }
      if (shouldRender) {
        const values = getFieldsValues(fieldsRef);
        set(values, name, rawValue);
        controllerSubjectRef.current.next({
          values: Object.assign(Object.assign({}, defaultValuesRef.current), values),
          name
        });
      }
      options.shouldDirty && updateAndGetDirtyState(name);
      options.shouldValidate && trigger(name);
    }
  }, []);
  const getFormIsDirty = React.useCallback((name, data) => {
    if (readFormStateRef.current.isDirty) {
      const formValues = getFieldsValues(fieldsRef);
      name && data && set(formValues, name, data);
      return !deepEqual(formValues, defaultValuesRef.current);
    }
    return false;
  }, []);
  const updateAndGetDirtyState = React.useCallback((name, shouldRender = true) => {
    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {
      const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(get(fieldsRef.current, name)));
      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);
      const previousIsDirty = formStateRef.current.isDirty;
      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);
      const state = {
        isDirty: getFormIsDirty(),
        dirtyFields: formStateRef.current.dirtyFields
      };
      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);
      isChanged && shouldRender && formStateSubjectRef.current.next(state);
      return isChanged ? state : {};
    }
    return {};
  }, []);
  const executeValidation = React.useCallback(async (name, skipReRender) => {
    const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];
    shouldRenderBaseOnError(name, error, skipReRender);
    return isUndefined(error);
  }, [isValidateAllFieldCriteria]);
  const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {
    const {errors} = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {
      criteriaMode,
      names: currentNames,
      fields: getFields(fieldsNamesRef.current, fieldsRef.current)
    });
    for (const name of names) {
      const error = get(errors, name);
      error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);
    }
    return errors;
  }, [criteriaMode]);
  const validateForm = /* @__PURE__ */ __name(async (fieldsRef2) => {
    for (const name in fieldsRef2) {
      const field = fieldsRef2[name];
      if (field) {
        const _f = field._f;
        const current = omit(field, "_f");
        if (_f) {
          const fieldError = await validateField(field, isValidateAllFieldCriteria);
          if (fieldError[_f.name]) {
            set(formStateRef.current.errors, _f.name, fieldError[_f.name]);
            unset(validFieldsRef.current, _f.name);
          } else if (get(fieldsWithValidationRef.current, _f.name)) {
            set(validFieldsRef.current, _f.name, true);
            unset(formStateRef.current.errors, _f.name);
          }
        }
        current && await validateForm(current);
      }
    }
  }, "validateForm");
  const trigger = React.useCallback(async (name) => {
    const fields = isUndefined(name) ? Object.keys(fieldsRef.current) : Array.isArray(name) ? name : [name];
    let isValid;
    formStateSubjectRef.current.next({
      isValidating: true
    });
    if (resolverRef.current) {
      isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name) ? void 0 : fields));
    } else {
      isUndefined(name) ? await validateForm(fieldsRef.current) : await Promise.all(fields.map(async (data) => await executeValidation(data, null)));
    }
    formStateSubjectRef.current.next({
      errors: formStateRef.current.errors,
      isValidating: false,
      isValid: resolverRef.current ? isValid : getIsValid()
    });
  }, [executeSchemaOrResolverValidation, executeValidation]);
  const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {
    const fieldName = `${name}.${inputKey}`;
    const field = get(fieldsRef.current, fieldName);
    field && !field._f ? setInternalValues(fieldName, inputValue, options) : setFieldValue(fieldName, inputValue, options, true, !field);
  }), [trigger]);
  const isFieldWatched = /* @__PURE__ */ __name((name) => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\w+/) || [])[0]), "isFieldWatched");
  const updateValueAndGetDefault = /* @__PURE__ */ __name((name) => {
    let defaultValue;
    const field = get(fieldsRef.current, name);
    if (field && (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))) {
      defaultValue = isUndefined(field._f.value) ? get(defaultValuesRef.current, name) : field._f.value;
      if (!isUndefined(defaultValue)) {
        setFieldValue(name, defaultValue);
      }
    }
    return defaultValue;
  }, "updateValueAndGetDefault");
  const setValue = /* @__PURE__ */ __name((name, value, options = {}) => {
    isMountedRef.current = true;
    const field = get(fieldsRef.current, name);
    const isFieldArray = fieldArrayNamesRef.current.has(name);
    if (isFieldArray) {
      fieldArraySubjectRef.current.next({
        fields: value,
        name,
        isReset: true
      });
      if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && options.shouldDirty) {
        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));
        formStateSubjectRef.current.next({
          dirtyFields: formStateRef.current.dirtyFields,
          isDirty: getFormIsDirty(name, value)
        });
      }
    }
    field && !field._f ? setInternalValues(name, value, isFieldArray ? {} : options) : setFieldValue(name, value, options, true, !field);
    isFieldWatched(name) && formStateSubjectRef.current.next({});
    watchSubjectRef.current.next({name, value});
  }, "setValue");
  const handleChange = React.useCallback(async ({type, target, target: {value, type: inputType}}) => {
    let name = target.name;
    let error;
    let isValid;
    const field = get(fieldsRef.current, name);
    if (field) {
      const inputValue = inputType ? getFieldValue(field) : value;
      const isBlurEvent = type === EVENTS.BLUR;
      const {isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange} = getValidationModes(reValidateMode);
      const shouldSkipValidation = skipValidation(Object.assign({
        isBlurEvent,
        isTouched: !!get(formStateRef.current.touchedFields, name),
        isSubmitted: formStateRef.current.isSubmitted,
        isReValidateOnBlur,
        isReValidateOnChange
      }, validationMode));
      const isWatched = !isBlurEvent && isFieldWatched(name);
      if (!isUndefined(inputValue)) {
        field._f.value = inputValue;
      }
      const state = updateAndGetDirtyState(name, false);
      if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {
        set(formStateRef.current.touchedFields, name, true);
        state.touchedFields = formStateRef.current.touchedFields;
      }
      let shouldRender = !isEmptyObject(state) || isWatched;
      if (shouldSkipValidation) {
        !isBlurEvent && watchSubjectRef.current.next({
          name,
          type,
          value: inputValue
        });
        return shouldRender && formStateSubjectRef.current.next(isWatched ? {} : state);
      }
      formStateSubjectRef.current.next({
        isValidating: true
      });
      if (resolverRef.current) {
        const {errors} = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {
          criteriaMode,
          fields: getFields([name], fieldsRef.current),
          names: [name]
        });
        const previousFormIsValid = formStateRef.current.isValid;
        error = get(errors, name);
        if (isCheckBoxInput(target) && !error) {
          const parentNodeName = getNodeParentName(name);
          const currentError = get(errors, parentNodeName, {});
          currentError.type && currentError.message && (error = currentError);
          if (currentError || get(formStateRef.current.errors, parentNodeName)) {
            name = parentNodeName;
          }
        }
        isValid = isEmptyObject(errors);
        previousFormIsValid !== isValid && (shouldRender = true);
      } else {
        error = (await validateField(field, isValidateAllFieldCriteria))[name];
      }
      !isBlurEvent && watchSubjectRef.current.next({
        name,
        type,
        value: inputValue
      });
      shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);
    }
  }, []);
  const getValues = /* @__PURE__ */ __name((fieldNames) => {
    const values = isMountedRef.current ? getFieldsValues(fieldsRef, defaultValuesRef) : defaultValuesRef.current;
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  }, "getValues");
  const updateIsValid = React.useCallback(async (values = {}) => {
    const previousIsValid = formStateRef.current.isValid;
    if (resolver) {
      const {errors} = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {
        criteriaMode,
        fields: getFields(fieldsNamesRef.current, fieldsRef.current)
      });
      formStateRef.current.isValid = isEmptyObject(errors);
    } else {
      getIsValid();
    }
    previousIsValid !== formStateRef.current.isValid && formStateSubjectRef.current.next({
      isValid: formStateRef.current.isValid
    });
  }, [criteriaMode]);
  const clearErrors = /* @__PURE__ */ __name((name) => {
    name && (Array.isArray(name) ? name : [name]).forEach((inputName) => unset(formStateRef.current.errors, inputName));
    formStateSubjectRef.current.next({
      errors: name ? formStateRef.current.errors : {}
    });
  }, "clearErrors");
  const setError = /* @__PURE__ */ __name((name, error, options) => {
    const ref = ((get(fieldsRef.current, name) || {_f: {}})._f || {}).ref;
    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {ref}));
    formStateSubjectRef.current.next({
      errors: formStateRef.current.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  }, "setError");
  const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal) => {
    const isArrayNames = Array.isArray(fieldNames);
    const fieldValues = isMountedRef.current ? getValues() : isUndefined(defaultValue) ? defaultValuesRef.current : isArrayNames ? defaultValue || {} : {[fieldNames]: defaultValue};
    if (isUndefined(fieldNames)) {
      isGlobal && (isWatchAllRef.current = true);
      return fieldValues;
    }
    const result = [];
    for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {
      isGlobal && watchFieldsRef.current.add(fieldName);
      result.push(get(fieldValues, fieldName));
    }
    return isArrayNames ? result : result[0];
  }, []);
  const watch = /* @__PURE__ */ __name((fieldName, defaultValue) => isFunction(fieldName) ? watchSubjectRef.current.subscribe({
    next: (info) => fieldName(watchInternal(void 0, defaultValue), info)
  }) : watchInternal(fieldName, defaultValue, true), "watch");
  const unregister = /* @__PURE__ */ __name((name, options = {}) => {
    for (const inputName of name ? Array.isArray(name) ? name : [name] : Object.keys(fieldsNamesRef.current)) {
      fieldsNamesRef.current.delete(inputName);
      fieldArrayNamesRef.current.delete(inputName);
      if (get(fieldsRef.current, inputName)) {
        if (!options.keepIsValid) {
          unset(fieldsWithValidationRef.current, inputName);
          unset(validFieldsRef.current, inputName);
        }
        !options.keepError && unset(formStateRef.current.errors, inputName);
        !options.keepValue && unset(fieldsRef.current, inputName);
        !options.keepDirty && unset(formStateRef.current.dirtyFields, inputName);
        !options.keepTouched && unset(formStateRef.current.touchedFields, inputName);
        !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);
        watchSubjectRef.current.next({
          name: inputName
        });
      }
    }
    formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), !options.keepDirty ? {} : {isDirty: getFormIsDirty()}), resolverRef.current ? {} : {isValid: getIsValid()}));
    if (!options.keepIsValid) {
      updateIsValid();
    }
  }, "unregister");
  const registerFieldRef = /* @__PURE__ */ __name((name, ref, options) => {
    let field = get(fieldsRef.current, name);
    if (field) {
      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);
      if ((isRadioOrCheckbox ? Array.isArray(field._f.refs) && compact(field._f.refs).find((option) => ref.value === option.value && option === ref) : ref === field._f.ref) || !field) {
        return;
      }
      field = {
        _f: isRadioOrCheckbox ? Object.assign(Object.assign({}, field._f), {refs: [
          ...compact(field._f.refs || []).filter((ref2) => isHTMLElement(ref2) && document.contains(ref2)),
          ref
        ], ref: {type: ref.type, name}}) : Object.assign(Object.assign({}, field._f), {ref})
      };
      set(fieldsRef.current, name, field);
      const defaultValue = updateValueAndGetDefault(name);
      if (isRadioOrCheckbox && Array.isArray(defaultValue) ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue) : isUndefined(get(fieldsRef.current, name)._f.value)) {
        get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));
      }
      if (options) {
        if (!validationMode.isOnSubmit && field && readFormStateRef.current.isValid) {
          validateField(field, isValidateAllFieldCriteria).then((error) => {
            isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);
            formStateRef.current.isValid && !isEmptyObject(error) && setFormState(Object.assign(Object.assign({}, formStateRef.current), {isValid: getIsValid()}));
          });
        }
      }
    }
  }, "registerFieldRef");
  const register = React.useCallback((name, options) => {
    set(fieldsRef.current, name, {
      _f: Object.assign(Object.assign(Object.assign({}, get(fieldsRef.current, name) ? Object.assign({ref: get(fieldsRef.current, name)._f.ref}, get(fieldsRef.current, name)._f) : {ref: {name}}), {name}), options)
    });
    options && set(fieldsWithValidationRef.current, name, true);
    fieldsNamesRef.current.add(name);
    updateValueAndGetDefault(name);
    return isWindowUndefined ? {name} : {
      name,
      onChange: handleChange,
      onBlur: handleChange,
      ref: (ref) => ref && registerFieldRef(name, ref, options)
    };
  }, [defaultValuesRef.current]);
  const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {
    if (e && e.preventDefault) {
      e.preventDefault();
      e.persist();
    }
    let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));
    formStateSubjectRef.current.next({
      isSubmitting: true
    });
    try {
      if (resolverRef.current) {
        const {errors, values} = await resolverRef.current(fieldValues, contextRef.current, {
          criteriaMode,
          fields: getFields(fieldsNamesRef.current, fieldsRef.current)
        });
        formStateRef.current.errors = errors;
        fieldValues = values;
      } else {
        await validateForm(fieldsRef.current);
      }
      if (isEmptyObject(formStateRef.current.errors) && Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {
        formStateSubjectRef.current.next({
          errors: {},
          isSubmitting: true
        });
        await onValid(fieldValues, e);
      } else {
        onInvalid && await onInvalid(formStateRef.current.errors, e);
        shouldFocusError && focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);
      }
    } finally {
      formStateRef.current.isSubmitted = true;
      formStateSubjectRef.current.next({
        isSubmitted: true,
        isSubmitting: false,
        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),
        submitCount: formStateRef.current.submitCount + 1,
        errors: formStateRef.current.errors
      });
    }
  }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);
  const resetFromState = React.useCallback(({keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepIsValid, keepSubmitCount}) => {
    if (!keepIsValid) {
      validFieldsRef.current = {};
      fieldsWithValidationRef.current = {};
    }
    watchFieldsRef.current = new Set();
    isWatchAllRef.current = false;
    formStateSubjectRef.current.next({
      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,
      isDirty: keepDirty ? formStateRef.current.isDirty : false,
      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,
      isValid: keepIsValid ? formStateRef.current.isValid : !validationMode.isOnSubmit,
      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},
      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},
      errors: keepErrors ? formStateRef.current.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  }, []);
  const reset = /* @__PURE__ */ __name((values, keepStateOptions = {}) => {
    const updatedValues = values || defaultValuesRef.current;
    if (isWeb && !keepStateOptions.keepValues) {
      for (const field of Object.values(fieldsRef.current)) {
        if (field && field._f) {
          const inputRef = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
          if (isHTMLElement(inputRef)) {
            try {
              inputRef.closest("form").reset();
              break;
            } catch (_a) {
            }
          }
        }
      }
    }
    !keepStateOptions.keepDefaultValues && (defaultValuesRef.current = Object.assign({}, updatedValues));
    if (!keepStateOptions.keepValues) {
      fieldsRef.current = {};
      controllerSubjectRef.current.next({
        values: Object.assign({}, updatedValues)
      });
      watchSubjectRef.current.next({
        value: Object.assign({}, updatedValues)
      });
      fieldArraySubjectRef.current.next({
        fields: Object.assign({}, updatedValues),
        isReset: true
      });
    }
    resetFromState(keepStateOptions);
  }, "reset");
  React.useEffect(() => {
    isMountedRef.current = true;
    const formStateSubscription = formStateSubjectRef.current.subscribe({
      next(formState2 = {}) {
        if (shouldRenderFormState(formState2, readFormStateRef.current, true)) {
          formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState2);
          setFormState(formStateRef.current);
        }
      }
    });
    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({
      next(state) {
        if (state.fields && state.name && readFormStateRef.current.isValid) {
          const values = getFieldsValues(fieldsRef);
          set(values, state.name, state.fields);
          updateIsValid(values);
        }
      }
    });
    resolverRef.current && readFormStateRef.current.isValid && updateIsValid();
    return () => {
      watchSubjectRef.current.unsubscribe();
      formStateSubscription.unsubscribe();
      useFieldArraySubscription.unsubscribe();
    };
  }, []);
  return {
    control: React.useMemo(() => ({
      register,
      isWatchAllRef,
      watchFieldsRef,
      getFormIsDirty,
      formStateSubjectRef,
      fieldArraySubjectRef,
      controllerSubjectRef,
      watchSubjectRef,
      watchInternal,
      fieldsRef,
      validFieldsRef,
      fieldsWithValidationRef,
      fieldArrayNamesRef,
      readFormStateRef,
      formStateRef,
      defaultValuesRef,
      fieldArrayDefaultValuesRef
    }), []),
    formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),
    trigger,
    register,
    handleSubmit,
    watch: React.useCallback(watch, []),
    setValue: React.useCallback(setValue, [setInternalValues]),
    getValues: React.useCallback(getValues, []),
    reset: React.useCallback(reset, []),
    clearErrors: React.useCallback(clearErrors, []),
    unregister: React.useCallback(unregister, []),
    setError: React.useCallback(setError, [])
  };
}
__name(useForm, "useForm");
var FormContext = React.createContext(null);
FormContext.displayName = "RHFContext";
var useFormContext = /* @__PURE__ */ __name(() => React.useContext(FormContext), "useFormContext");
var FormProvider = /* @__PURE__ */ __name((props) => React.createElement(FormContext.Provider, {value: omit(props, "children")}, props.children), "FormProvider");
var generateId = /* @__PURE__ */ __name(() => {
  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16 + d) % 16 | 0;
    return (c == "x" ? r : r & 3 | 8).toString(16);
  });
}, "generateId");
var mapIds = /* @__PURE__ */ __name((values = [], keyName) => values.map((value) => Object.assign({[keyName]: value && value[keyName] || generateId()}, value)), "mapIds");
function removeAtIndexes(data, indexes) {
  let i = 0;
  const temp = [...data];
  for (const index of indexes) {
    temp.splice(index - i, 1);
    i++;
  }
  return compact(temp).length ? temp : [];
}
__name(removeAtIndexes, "removeAtIndexes");
var removeArrayAt = /* @__PURE__ */ __name((data, index) => isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b)), "removeArrayAt");
var moveArrayAt = /* @__PURE__ */ __name((data, from, to) => {
  if (Array.isArray(data)) {
    if (isUndefined(data[to])) {
      data[to] = void 0;
    }
    data.splice(to, 0, data.splice(from, 1)[0]);
    return data;
  }
  return [];
}, "moveArrayAt");
var swapArrayAt = /* @__PURE__ */ __name((data, indexA, indexB) => {
  data[indexA] = [data[indexB], data[indexB] = data[indexA]][0];
}, "swapArrayAt");
function prepend(data, value) {
  return [...Array.isArray(value) ? value : [value], ...data];
}
__name(prepend, "prepend");
function append(data, value) {
  return [...data, ...Array.isArray(value) ? value : [value]];
}
__name(append, "append");
function insert(data, index, value) {
  return [
    ...data.slice(0, index),
    ...Array.isArray(value) ? value : [value],
    ...data.slice(index)
  ];
}
__name(insert, "insert");
var fillEmptyArray = /* @__PURE__ */ __name((value) => Array.isArray(value) ? Array(value.length).fill(void 0) : void 0, "fillEmptyArray");
var useFieldArray = /* @__PURE__ */ __name(({control, name, keyName = "id"}) => {
  const methods = useFormContext();
  const focusNameRef = React.useRef("");
  const {isWatchAllRef, watchFieldsRef, getFormIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef} = control || methods.control;
  const [fields, setFields] = React.useState(mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name)) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(defaultValuesRef.current, name, []), keyName));
  set(fieldArrayDefaultValuesRef.current, name, [...fields]);
  fieldArrayNamesRef.current.add(name);
  const omitKey = /* @__PURE__ */ __name((fields2) => fields2.map((field) => omit(field || {}, keyName)), "omitKey");
  const getCurrentFieldsValues = /* @__PURE__ */ __name(() => {
    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);
    return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => Object.assign(Object.assign({}, item), values[index])), keyName);
  }, "getCurrentFieldsValues");
  const getFocusDetail = /* @__PURE__ */ __name((index, options) => options ? !isUndefined(options.focusIndex) ? `${name}.${options.focusIndex}` : options.focusName ? options.focusName : !options.shouldFocus ? "" : `${name}.${index}` : `${name}.${index}`, "getFocusDetail");
  const resetFields = /* @__PURE__ */ __name((index) => (Array.isArray(index) ? index : [index]).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? "" : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : void 0)), "resetFields");
  const setFieldsAndNotify = /* @__PURE__ */ __name((fieldsValues = []) => setFields(mapIds(fieldsValues, keyName)), "setFieldsAndNotify");
  const cleanup = /* @__PURE__ */ __name((ref) => !compact(get(ref, name, [])).length && unset(ref, name), "cleanup");
  const updateDirtyFieldsWithDefaultValues = /* @__PURE__ */ __name((updatedFieldArrayValues) => updatedFieldArrayValues && set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, []))), "updateDirtyFieldsWithDefaultValues");
  const batchStateUpdate = /* @__PURE__ */ __name((method, args, updatedFieldArrayValues = [], shouldSet = true) => {
    if (get(fieldsRef.current, name)) {
      const output = method(get(fieldsRef.current, name), args.argA, args.argB);
      shouldSet && set(fieldsRef.current, name, output);
    }
    if (Array.isArray(get(formStateRef.current.errors, name))) {
      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);
      shouldSet && set(formStateRef.current.errors, name, output);
      cleanup(formStateRef.current.errors);
    }
    if (readFormStateRef.current.touchedFields && get(formStateRef.current.touchedFields, name)) {
      const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);
      shouldSet && set(formStateRef.current.touchedFields, name, output);
      cleanup(formStateRef.current.touchedFields);
    }
    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {
      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));
      updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);
      cleanup(formStateRef.current.dirtyFields);
    }
    if (readFormStateRef.current.isValid) {
      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));
      cleanup(validFieldsRef.current);
      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));
      cleanup(fieldsWithValidationRef.current);
    }
    formStateSubjectRef.current.next({
      isDirty: getFormIsDirty(name, omitKey(updatedFieldArrayValues)),
      errors: formStateRef.current.errors,
      isValid: formStateRef.current.isValid
    });
  }, "batchStateUpdate");
  const registerFieldArray = /* @__PURE__ */ __name((values, index = 0, parentName = "") => values.forEach((appendValueItem, valueIndex) => Object.entries(appendValueItem).forEach(([key, value]) => {
    const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;
    Array.isArray(value) ? registerFieldArray(value, valueIndex, inputName) : set(fieldsRef.current, inputName, {
      _f: {
        ref: {
          name: inputName
        },
        name: inputName,
        value
      }
    });
  })), "registerFieldArray");
  const append$1 = /* @__PURE__ */ __name((value, options) => {
    const appendValue = Array.isArray(value) ? value : [value];
    const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);
    const currentIndex = updatedFieldArrayValues.length - appendValue.length;
    setFieldsAndNotify(updatedFieldArrayValues);
    batchStateUpdate(append, {
      argA: fillEmptyArray(value)
    }, updatedFieldArrayValues, false);
    registerFieldArray(appendValue, currentIndex);
    focusNameRef.current = getFocusDetail(currentIndex, options);
  }, "append$1");
  const prepend$1 = /* @__PURE__ */ __name((value, options) => {
    const prependValue = Array.isArray(value) ? value : [value];
    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);
    setFieldsAndNotify(updatedFieldArrayValues);
    batchStateUpdate(prepend, {
      argA: fillEmptyArray(value)
    }, updatedFieldArrayValues);
    registerFieldArray(prependValue);
    focusNameRef.current = getFocusDetail(0, options);
  }, "prepend$1");
  const remove = /* @__PURE__ */ __name((index) => {
    const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);
    resetFields(index);
    setFieldsAndNotify(updatedFieldArrayValues);
    batchStateUpdate(removeArrayAt, {
      argA: index
    }, updatedFieldArrayValues);
  }, "remove");
  const insert$1 = /* @__PURE__ */ __name((index, value, options) => {
    const insertValue = Array.isArray(value) ? value : [value];
    const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);
    setFieldsAndNotify(updatedFieldArrayValues);
    batchStateUpdate(insert, {
      argA: index,
      argB: fillEmptyArray(value)
    }, updatedFieldArrayValues);
    registerFieldArray(insertValue, index);
    focusNameRef.current = getFocusDetail(index, options);
  }, "insert$1");
  const swap = /* @__PURE__ */ __name((indexA, indexB) => {
    const fieldValues = getCurrentFieldsValues();
    swapArrayAt(fieldValues, indexA, indexB);
    batchStateUpdate(swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, fieldValues, false);
    setFieldsAndNotify(fieldValues);
  }, "swap");
  const move = /* @__PURE__ */ __name((from, to) => {
    const fieldValues = getCurrentFieldsValues();
    moveArrayAt(fieldValues, from, to);
    setFieldsAndNotify(fieldValues);
    batchStateUpdate(moveArrayAt, {
      argA: from,
      argB: to
    }, fieldValues, false);
  }, "move");
  React.useEffect(() => {
    if (isWatchAllRef.current) {
      formStateSubjectRef.current.next({});
    } else {
      for (const watchField of watchFieldsRef.current) {
        if (name.startsWith(watchField)) {
          formStateSubjectRef.current.next({});
          break;
        }
      }
    }
    watchSubjectRef.current.next({
      name,
      value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, [])
    });
    focusNameRef.current && focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));
    focusNameRef.current = "";
    fieldArraySubjectRef.current.next({
      name,
      fields: omitKey([...fields])
    });
  }, [fields, name]);
  React.useEffect(() => {
    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({
      next({name: inputFieldArrayName, fields: fields2, isReset}) {
        if (isReset) {
          unset(fieldsRef.current, inputFieldArrayName || name);
          inputFieldArrayName ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields2) : fieldArrayDefaultValuesRef.current = fields2;
          setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));
        }
      }
    });
    !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);
    return () => {
      fieldArrayDefaultValuesRef.current = getFieldsValues(fieldsRef);
      fieldArraySubscription.unsubscribe();
    };
  }, []);
  return {
    swap: React.useCallback(swap, [name]),
    move: React.useCallback(move, [name]),
    prepend: React.useCallback(prepend$1, [name]),
    append: React.useCallback(append$1, [name]),
    remove: React.useCallback(remove, [name]),
    insert: React.useCallback(insert$1, [name]),
    fields
  };
}, "useFieldArray");
function useFormState({control} = {}) {
  const methods = useFormContext();
  const {formStateRef, formStateSubjectRef, readFormStateRef} = control || methods.control;
  const [formState, updateFormState] = React.useState(formStateRef.current);
  const readFormState = React.useRef({
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  React.useEffect(() => {
    const formStateSubscription = formStateSubjectRef.current.subscribe({
      next: (formState2) => {
        shouldRenderFormState(formState2, readFormState.current) && updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState2));
      }
    });
    return () => formStateSubscription.unsubscribe();
  }, []);
  return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);
}
__name(useFormState, "useFormState");
var getControllerValue = /* @__PURE__ */ __name((event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event, "getControllerValue");
var isNameInFieldArray = /* @__PURE__ */ __name((names, name) => [...names].some((current) => getNodeParentName(name) === current), "isNameInFieldArray");
function useController({name, rules, defaultValue, control}) {
  const methods = useFormContext();
  const {defaultValuesRef, register, fieldsRef, fieldArrayNamesRef, controllerSubjectRef} = control || methods.control;
  const {onChange, onBlur, ref} = register(name, rules);
  const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) || isNameInFieldArray(fieldArrayNamesRef.current, name) ? isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue : get(fieldsRef.current, name)._f.value);
  const formState = useFormState({
    control: control || methods.control
  });
  get(fieldsRef.current, name)._f.value = value;
  React.useEffect(() => {
    const controllerSubscription = controllerSubjectRef.current.subscribe({
      next: (data) => (!data.name || name === data.name) && setInputStateValue(get(data.values, name))
    });
    return () => controllerSubscription.unsubscribe();
  }, [name]);
  return {
    field: {
      onChange: (event) => {
        const value2 = getControllerValue(event);
        setInputStateValue(value2);
        onChange({
          target: {
            value: value2,
            name
          },
          type: EVENTS.CHANGE
        });
      },
      onBlur: () => {
        onBlur({
          target: {
            name
          },
          type: EVENTS.BLUR
        });
      },
      name,
      value,
      ref
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        get() {
          return !!get(formState.errors, name);
        }
      },
      isDirty: {
        get() {
          return !!get(formState.dirtyFields, name);
        }
      },
      isTouched: {
        get() {
          return !!get(formState.touchedFields, name);
        }
      },
      error: {
        get() {
          return get(formState.errors, name);
        }
      }
    })
  };
}
__name(useController, "useController");
function useWatch(props) {
  const {control, name, defaultValue} = props || {};
  const methods = useFormContext();
  const {watchInternal, watchSubjectRef} = control || methods.control;
  const [value, updateValue] = React.useState(isUndefined(defaultValue) ? watchInternal(name) : defaultValue);
  React.useEffect(() => {
    watchInternal(name);
    const watchSubscription = watchSubjectRef.current.subscribe({
      next: ({name: inputName, value: value2}) => {
        (!name || !inputName || (Array.isArray(name) ? name : [name]).some((fieldName) => inputName && fieldName && inputName.startsWith(fieldName))) && updateValue(isString(inputName) && name === inputName && !isUndefined(value2) ? value2 : watchInternal(name, defaultValue));
      }
    });
    return () => watchSubscription.unsubscribe();
  }, [name]);
  return value;
}
__name(useWatch, "useWatch");
var Controller = /* @__PURE__ */ __name((props) => props.render(useController(props)), "Controller");
export {
  Controller,
  FormProvider,
  appendErrors,
  get,
  set,
  useController,
  useFieldArray,
  useForm,
  useFormContext,
  useFormState,
  useWatch
};
//# sourceMappingURL=react-hook-form.js.map
